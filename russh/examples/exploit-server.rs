use std::collections::HashMap;
use std::sync::Arc;
use std::str;
use clap::Parser;

use async_trait::async_trait;
use log::info;
use russh::server::{Msg, Session};
use russh::*;
use tokio::sync::Mutex;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Command to execute on remote agent
    #[arg(short, long)]
    cmd: String,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();

    env_logger::builder()
        // .filter_level(log::LevelFilter::Debug)
        .filter_level(log::LevelFilter::Info)
        .init();

    let config = russh::server::Config {
        connection_timeout: Some(std::time::Duration::from_secs(3600)),
        auth_rejection_time: std::time::Duration::from_secs(3),
        auth_rejection_time_initial: Some(std::time::Duration::from_secs(0)),
        keys: vec![russh_keys::key::KeyPair::generate_ed25519().unwrap()],
        ..Default::default()
    };
    let config = Arc::new(config);
    let sh = Server {
        clients: Arc::new(Mutex::new(HashMap::new())),
        id: 0,
        cmd : args.cmd,
    };
    russh::server::run(config, ("0.0.0.0", 2222), sh)
        .await
        .unwrap();
}

#[derive(Clone)]
struct Server {
    clients: Arc<Mutex<HashMap<(usize, ChannelId), russh::server::Handle>>>,
    id: usize,
    cmd: String,
}

impl server::Server for Server {
    type Handler = Self;
    fn new_client(&mut self, _: Option<std::net::SocketAddr>) -> Self {
        let s = self.clone();
        self.id += 1;
        s
    }
}

#[async_trait]
impl server::Handler for Server {
    type Error = anyhow::Error;

    async fn channel_open_session(
        self,
        channel: Channel<Msg>,
        session: Session,
    ) -> Result<(Self, bool, Session), Self::Error> {
        {
            let mut clients = self.clients.lock().await;
            clients.insert((self.id, channel.id()), session.handle());
        }
        Ok((self, true, session))
    }

    async fn auth_none(self, _user: &str) -> Result<(Self, server::Auth), Self::Error> {
        Ok((self, server::Auth::Accept))
    }
    async fn auth_password(self, _user: &str, _password: &str) -> Result<(Self, server::Auth), Self::Error> {
        Ok((self, server::Auth::Accept))
    }

    async fn exec_request(
        mut self,
        channel: ChannelId,
        data: &[u8],
        mut session: Session,
    ) -> Result<(Self, Session), Self::Error> {
        let cmd = String::from_utf8_lossy(data);
        info!("processing exec_request: {}", cmd);

        let data: CryptoVec;
        let mut exit_status = 0;

        match cmd.into_owned().as_str() {
            "LANG=C uname -s" => {
                data = CryptoVec::from_slice(b"aix\n");
            },
            "LANG=C which ps" => {

                data = CryptoVec::from_slice(format!("';{};echo '\n", self.cmd).as_bytes());
            },
            _ => {
                data = CryptoVec::from_slice(b"command not found ...\n");
                exit_status = 127;
            }
        }

        session.data(channel, data);
        session.exit_status_request(channel, exit_status);
        session.close(channel);

        Ok((self, session))
    }
}
